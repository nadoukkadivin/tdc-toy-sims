#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
tdc_eg2_toysim.py – Gut-Brain Axis Simulation with TDC Physics

Validates TDC framework for multi-domain signal propagation with:
1. Substrate-agnostic parameters (Dr, S, I, r, α)
2. Entropy-driven transduction at interfaces
3. Residue accumulation across domains
4. Thermal resilience benchmarking
"""

import numpy as np
from scipy.integrate import odeint
import matplotlib.pyplot as plt
from datetime import datetime
import sys

np.random.seed(42)  # Reproducibility

# ==== DOMAIN PHYSICS ====
DOMAINS = ['Gut', 'Blood', 'Brain']
N = len(DOMAINS)
k_B = 1.38e-23
Cm = 1e-6
T_env = 310  # 37°C
T_high = 323  # 50°C

# Domain-specific timescales (s)
TAU_D = [2.0, 0.5, 0.0015]  # Gut(2s), Blood(0.5s), Brain(1.5ms)
Q10_FACTORS = [1.8, 2.5, 3.0]  # Temperature sensitivity

# ==== CROSS-DOMAIN TRANSDUCTION ====
def entropy_transduction(signal, T, domain_from, domain_to):
    """Physics-based signal transduction using entropy gradients"""
    dS = Q10_FACTORS[domain_to] / Q10_FACTORS[domain_from]
    loss = 0.3 + 0.1 * np.random.normal()  # 30±10% loss
    return signal * np.sqrt(dS) * (1 - loss)

# ==== BIOPHYSICAL MODELS ====
def hh_langevin_domain(V, t, T, noise_scale, domain_idx):
    """Domain-adapted Hodgkin-Huxley + Langevin"""
    phi = Q10_FACTORS[domain_idx] ** ((T - 298) / 10)
    
    # Gut: Chemical-like dynamics (dimensionless)
    if domain_idx == 0:
        dVdt = 0.05 * (1 - V) + noise_scale * np.random.normal()
        return dVdt
    
    # Blood/Brain: Electrical dynamics
    alpha_n = phi * 0.01 * (V + 55) / (1 - np.exp(-(V + 55) / 10))
    beta_n = phi * 0.125 * np.exp(-(V + 65) / 80)
    n_inf = alpha_n / (alpha_n + beta_n)
    
    alpha_m = phi * 0.1 * (V + 40) / (1 - np.exp(-(V + 40) / 10))
    beta_m = phi * 4.0 * np.exp(-(V + 65) / 18)
    m_inf = alpha_m / (alpha_m + beta_m)
    
    alpha_h = phi * 0.07 * np.exp(-(V + 65) / 20)
    beta_h = phi * 1.0 / (1 + np.exp(-(V + 35) / 10))
    h_inf = alpha_h / (alpha_h + beta_h)
    
    # Currents
    gNa, gK, gL = [120e-3, 36e-3, 0.3e-3] 
    ENa, EK, EL = [55, -77, -54]
    INa = gNa * m_inf**3 * h_inf * (V - ENa)
    IK = gK * n_inf**4 * (V - EK)
    IL = gL * (V - EL)
    
    # Noise (domain-scaled)
    noise = noise_scale * np.sqrt(4 * k_B * T * Cm) * np.random.normal()
    return - (INa + IK + IL) + noise

# ==== TDC CORE MODEL ====
def tdc_domain(t, Dr, S, I, r0, alpha, T, domain_idx):
    """TDC substrate-agnostic formulation"""
    τ_d = TAU_D[domain_idx]
    τ_c = Dr * τ_d
    phi = Q10_FACTORS[domain_idx] ** ((T - 298) / 10)
    
    # Gut: Slow chemical waves
    if domain_idx == 0:
        persistence = I * np.exp(-t / τ_d) * np.cos(2 * np.pi * t / (τ_c * 10))
    # Blood/Brain: Electrical signals
    else:
        persistence = I * np.exp(-t / τ_d) * np.cos(2 * np.pi * t / τ_c)
    
    # Entropy scales with thermal energy
    entropy = S * np.sqrt(2 * k_B * T * Cm) * np.random.normal(size=len(t))
    
    # Residue decays at domain-specific rate
    residue = r0 * np.exp(-alpha * t * phi)
    return persistence + entropy + residue

# ==== SIGNAL PROPAGATION ====
def propagate_signal(t, model_func, params, T):
    """Cross-domain propagation with TDC physics"""
    signals = []
    residues = [np.zeros(len(t)) for _ in range(N)]
    
    for i in range(N):
        # Generate domain signal
        domain_params = {k: v[i] if isinstance(v, list) else v for k, v in params.items()}
        signal = model_func(t, T=T, domain_idx=i, **domain_params)
        
        # Add residue from previous domain
        if i > 0:
            signal += 0.4 * residues[i-1]  # Residue carryover
        
        # Store and update residue
        signals.append(signal)
        residues[i] = domain_params['r0'] * signal * np.exp(-domain_params['alpha'] * t * Q10_FACTORS[i])
        
        # Cross-domain transduction
        if i < N-1:
            signals[i+1] = entropy_transduction(signal, T, i, i+1)
    
    return np.array(signals), residues

# ==== VALIDATION METRICS ====
def calculate_snr(signals, t):
    """Domain-specific SNR calculation"""
    snr = []
    domain_windows = [(100, 400), (3, 8), (5, 10)]  # Gut, Blood, Brain (ms)
    
    for i, (start, end) in enumerate(domain_windows):
        idx = (t >= start) & (t <= end)
        sig_segment = signals[i][idx]
        
        # Handle dimensionless gut signals
        if i == 0:
            signal_power = np.mean(sig_segment**2)
            noise_power = np.var(sig_segment)
        # Electrical domains
        else:
            smoothed = np.convolve(sig_segment, np.ones(10)/10, 'same')
            signal_power = np.mean(sig_segment**2)
            noise_power = np.var(sig_segment - smoothed)
        
        snr.append(10 * np.log10(signal_power / noise_power))
    return snr

# ==== MAIN SIMULATION ====
if __name__ == "__main__":
    # Time vector (extended for gut dynamics)
    t = np.linspace(0, 500, 5000)  # 500ms simulation
    
    # --- Model Parameters ---
    # Baseline HH-Langevin
    hh_params = {
        'noise_scale': [0.3, 0.4, 0.2]  # Gut, Blood, Brain
    }
    
    # TDC Parameters (domain-optimized)
    tdc_params = {
        'Dr': [0.1, 0.2, 0.3],      # Persistence increase downstream
        'S': [0.25, 0.18, 0.12],     # Entropy decrease downstream
        'I': [0.8, 1.2, 1.5],        # Signal strength (dimensionless)
        'r0': [0.4, 0.3, 0.2],       # Residue amplitude
        'alpha': [1/200, 1/100, 1/50] # Residue decay (slower in brain)
    }
    
    # --- Simulate at 37°C ---
    V_hh, _ = propagate_signal(t, hh_langevin_domain, hh_params, T_env)
    V_tdc, residues = propagate_signal(t, tdc_domain, tdc_params, T_env)
    
    # --- Thermal Stress Test (50°C) ---
    V_hh_hot, _ = propagate_signal(t, hh_langevin_domain, hh_params, T_high)
    V_tdc_hot, _ = propagate_signal(t, tdc_domain, tdc_params, T_high)
    
    # --- SNR Calculations ---
    snr_hh = calculate_snr(V_hh, t)
    snr_tdc = calculate_snr(V_tdc, t)
    snr_hh_hot = calculate_snr(V_hh_hot, t)
    snr_tdc_hot = calculate_snr(V_tdc_hot, t)
    
    # --- Parameter Reduction ---
    hh_param_count = 8 * N  # 8 params per domain
    tdc_param_count = 5 * N  # 5 TDC params per domain
    param_reduction = (hh_param_count - tdc_param_count) / hh_param_count * 100
    
    print(f"\n=== TDC GUT-BRAIN VALIDATION ===")
    print(f"PARAMETER REDUCTION: {param_reduction:.1f}%")
    for i, domain in enumerate(DOMAINS):
        print(f"{domain}:")
        print(f"  37°C: HH={snr_hh[i]:.1f}dB, TDC={snr_tdc[i]:.1f}dB → Δ={snr_tdc[i]-snr_hh[i]:.1f}dB")
        print(f"  50°C: HH={snr_hh_hot[i]:.1f}dB, TDC={snr_tdc_hot[i]:.1f}dB → Δ={snr_tdc_hot[i]-snr_hh_hot[i]:.1f}dB")
    
    # --- Physics Validation ---
    validation_passed = True
    try:
        # 1. Parameter reduction (min 37.5%)
        assert param_reduction >= 37.5, f"Param reduction {param_reduction:.1f}% < 37.5%"
        
        # 2. SNR tolerance per domain
        tolerance = [-1.5, -0.5, 0]  # Gut, Blood, Brain (dB)
        for i in range(N):
            assert (snr_tdc[i] - snr_hh[i]) > tolerance[i], f"Domain {DOMAINS[i]} SNR degraded"
        
        # 3. Thermal resilience (avg >2dB gain)
        thermal_gain = np.mean([snr_tdc_hot[i] - snr_hh_hot[i] for i in range(N)])
        assert thermal_gain > 2.0, f"Thermal gain {thermal_gain:.1f}dB ≤ 2dB"
        
    except AssertionError as e:
        print(f"❌ VALIDATION FAILED: {e}")
        validation_passed = False
    else:
        print("✅ VALIDATION PASSED")
    
    # --- Plotting ---
    fig, axs = plt.subplots(N, 1, figsize=(12, 10), sharex=True)
    for i, domain in enumerate(DOMAINS):
        # Plot signals
        axs[i].plot(t, V_hh[i], 'b-', label=f'HH {domain}', lw=1.5)
        axs[i].plot(t, V_tdc[i], 'r--', label=f'TDC {domain}', lw=1.5)
        axs[i].plot(t, residues[i], 'g:', label=f'TDC Residue', alpha=0.7)
        
        # Formatting
        axs[i].set_ylabel('Signal' if i==0 else 'Potential (mV)')
        axs[i].legend()
        axs[i].grid(True, alpha=0.3)
        if i == 0:
            axs[i].set_title("TDC Multi-Domain Propagation: Gut → Blood → Brain")
    
    plt.xlabel("Time (ms)")
    plt.tight_layout()
    
    # Save results
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    plt.savefig(f"tdc_eg2_results_{timestamp}.pdf", dpi=300, bbox_inches='tight')
    plt.savefig(f"tdc_eg2_results_{timestamp}.png", dpi=300)
    print(f"Saved: tdc_eg2_results_{timestamp}.pdf/png")
    
    # CI/CD Exit Code
    sys.exit(0 if validation_passed else 1)
